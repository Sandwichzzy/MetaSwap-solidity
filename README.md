Uniswap V2 和 Uniswap V3 的差异，在 V2 和 V3 中，一个代币对和费率唯一确定了一个交易池，在 V2 中，LP 向这样一个池子中注入流动性，价格可以在正无穷到负无穷之间波动。V3 相比 V2 最大的差异就是在 LP 注入流动性时可以定义一个价格区间，让 LP 可以提升自身的资金利用率。但是这样会导致 V3 交易的逻辑更复杂，因为一个池子里面可能包含了不同价格区间的流动性，交易的逻辑会更复杂。

```
在 MetaSwap 的设计中，我们也会引入价格区间，作为相比 V2 新增的功能，但是我们将不同的价格区间的流动性放到不同的池子中，用来降低复杂度。这样我们的交易逻辑会更简单，但是需要说明的是这样也会让流动性更分散，这也是为什么 V3 不这么做的原因。

对于 MetaSwap 来说，整体设计相比 Uniswap V2 和 V3 我们会做如下的设计：

1. 简化功能，不支持部分添加和提取流动性，不支持和原生代币交易，不支持跨交易对交易。
2. 一个代币对+费率+价格区间唯一确定一个交易池，相比 Uniswap V2 来说我们针对交易池新增了价格区间的信息。
3. 一个代币对下可能会有多个交易池，交易池的费率和价格区间都可以灵活设置，选择在哪些交易池中交易由 DApp 前端通过流动性情况选择。
4. 直接调用合约获取当前可供交易的交易池，使得 DApp 不依赖于服务端（在 Uniswap 自己的 DApp 实现会涉及到一些服务端的接口）。
```

合约需求：
MetaSwap 设计每个池子都有一个价格范围，swap 只能在此价格范围内成交:

1. 任何人都可以创建池子，创建池子可以指定当前价格、价格范围： [a, b] 和 费率 f；相同交易对和费率可以有多个池子；不能删除和修改池子；
2. 任何人都可以添加流动性，添加流动性只能在指定价格范围 [a, b]；
3. 流动性提供者可以减少添加的流动性，并提取减少流动性对应的两种代币；
4. 流动性提供者可以在任何人 swap 过程收取手续费，手续费为 f，按流动性贡献加权平分给流动性提供者(手续费的收取方式和 Uniswap 有所差异，做了简化)；
5. 任何人都可以 swap，swap 需要指定某个池子，swap 可以指定输入（最大化输出）或者指定输出（最小化输入），如果指定的池子的流动性不足，则只会部分成交。

以简单为原则，我们不按照 Uniswap V3 将合约分为 periphery 和 core 两个独立仓库，而是自顶向下分为以下四个合约。
PoolManager.sol: 顶层合约，对应 Pool 页面，负责 Pool 的创建和管理。
PositionManager.sol: 顶层合约，对应 Position 页面，负责 LP 头寸和流动性的管理；
SwapRouter.sol: 顶层合约，对应 Swap 页面，负责预估价格和交易；
Factory.sol: 底层合约，Pool 的工厂合约；
Pool.sol: 最底层合约，对应一个交易池，记录了当前价格、头寸、流动性等信息。

在 AMM（自动做市商）交易中，有两种基本的交易模式：

1. ExactInput（指定输入）
   用户指定：我要用多少 tokenIn
   系统计算：你能得到多少 tokenOut
   风险：滑点风险（可能得到的 tokenOut 比预期少）
2. ExactOutput（指定输出）
   用户指定：我要得到多少 tokenOut
   系统计算：你需要用多少 tokenIn
   风险：滑点风险（可能需要用的 tokenIn 比预期多）
   // 交易方向：tokenIn -> tokenOut
   address tokenIn; // 输入代币地址（你要花掉的代币）
   address tokenOut; // 输出代币地址（你要得到的代币）

   // 实际交易数量
   uint256 amountIn; // 实际使用的输入代币数量
   uint256 amountOut; // 实际得到的输出代币数量

   // 滑点保护参数
   uint256 amountInMaximum; // 最多愿意使用的输入代币数量（滑点保护上限）
   uint256 amountOutMinimum; // 最少要得到的输出代币数量（滑点保护下限）
