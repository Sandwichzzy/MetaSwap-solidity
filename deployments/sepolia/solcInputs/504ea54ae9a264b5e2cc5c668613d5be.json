{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (token/ERC20/IERC20.sol)\n\npragma solidity >=0.4.16;\n\n/**\n * @dev Interface of the ERC-20 standard as defined in the ERC.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "contracts/Factory.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/IFactory.sol\";\r\nimport \"./Pool.sol\";\r\n\r\ncontract Factory is IFactory {\r\n\r\n    Parameters public override parameters;\r\n\r\n    mapping(address => mapping(address => address[])) public  pools;\r\n\r\n    function sortToken(address tokenA,address tokenB) private pure returns (address,address){\r\n        return tokenA < tokenB ? (tokenA, tokenB) : (tokenB, tokenA);\r\n    }\r\n\r\n    function createPool(address tokenA, address tokenB, int24 tickLower, int24 tickUpper, uint24 fee) \r\n        external returns (address pool){\r\n        require(tokenA != tokenB, \"TokenA and TokenB cannot be the same\");\r\n\r\n        address token0;\r\n        address token1;\r\n        // sort token, avoid the mistake of the order 将tokenA和tokenB按大小排序\r\n        (token0,token1) = sortToken(tokenA, tokenB);\r\n\r\n        //get current all pools\r\n        address[] memory existingPools  = pools[token0][token1];\r\n        // check if the pool already exists \r\n        // 有点耗gas，可以优化\r\n        for(uint i = 0; i < existingPools.length; i++){\r\n            IPool currentPool =IPool(existingPools[i]);\r\n            if (currentPool.tickLower() == tickLower && \r\n                currentPool.tickUpper() == tickUpper && \r\n                currentPool.fee() == fee){\r\n                // if the pool already exists, return the pool\r\n                return existingPools[i];\r\n            }\r\n        }\r\n        //save the pool info\r\n        parameters = Parameters(address(this), tokenA, tokenB, tickLower, tickUpper, fee);\r\n        // generate create2 salt\r\n        bytes32 salt = keccak256(abi.encode(token0, token1, tickLower, tickUpper, fee));\r\n        // create pool\r\n        // salt 来使用 CREATE2 的方式来创建合约，这样的好处是创建出来的合约地址是可预测的，\r\n        // 地址生成的逻辑是 新地址 = hash(\"0xFF\",创建者地址, salt, initcode)\r\n        pool=address(new Pool{salt:salt}());\r\n        // save created pool\r\n        pools[token0][token1].push(pool);\r\n        // delete pool info\r\n        delete parameters;\r\n        //emit PoolCreated event\r\n        emit PoolCreated(token0, token1, uint32(existingPools.length), tickLower, tickUpper, fee, pool);\r\n    }\r\n\r\n    function getPool(address tokenA, address tokenB, uint32 index) external view override returns (address pool){\r\n        require(tokenA != tokenB, \"TokenA and TokenB cannot be the same\");\r\n        require(tokenA != address(0) && tokenB != address(0), \"ZERO_ADDRESS\");\r\n\r\n        address token0;\r\n        address token1;\r\n\r\n        (token0,token1) = sortToken(tokenA, tokenB);\r\n\r\n        pool = pools[token0][token1][index];\r\n\r\n        require(pool != address(0), \"POOL_NOT_EXISTS\");\r\n\r\n        return pool;\r\n    }\r\n\r\n    \r\n}"
    },
    "contracts/interfaces/IFactory.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.0;\r\n\r\ninterface IFactory {\r\n    struct Parameters {\r\n        address factory;\r\n        address tokenA;\r\n        address tokenB;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint24 fee;\r\n    }\r\n\r\n    function parameters() external view returns (        \r\n        address factory,\r\n        address tokenA,\r\n        address tokenB,\r\n        int24 tickLower,\r\n        int24 tickUpper,\r\n        uint24 fee\r\n    );\r\n\r\n\r\n\r\n    event PoolCreated(address token0, address token1,uint32 index, int24 tickLower, int24 tickUpper, uint24 fee,address pool);\r\n\r\n    function getPool(address tokenA, address tokenB, uint32 index) external view returns (address pool);\r\n\r\n    function createPool(address tokenA, address tokenB, int24 tickLower, int24 tickUpper, uint24 fee) external returns (address pool);\r\n}"
    },
    "contracts/interfaces/IPool.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\ninterface IMintCallback {\r\n    function mintCallback(uint256 amount0Owed, uint256 amount1Owed, bytes calldata data) external;\r\n}\r\n\r\ninterface ISwapCallback {\r\n    function swapCallback(int256 amount0Delta, int256 amount1Delta, bytes calldata data) external;\r\n}\r\n\r\ninterface IPool {\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function fee() external view returns (uint24);\r\n    function tickLower() external view returns (int24);\r\n    function tickUpper() external view returns (int24);\r\n    function sqrtPriceX96() external view returns (uint160);\r\n    function tick() external view returns (int24);\r\n    function liquidity() external view returns (uint128);\r\n\r\n    function initialize(uint160 sqrtPriceX96) external;\r\n   /// feeGrowthGlobal0X128 记录从创建到现在，每个流动性累计产生的 token0 的手续费\r\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\r\n    /// @dev This value can overflow the uint256\r\n    function feeGrowthGlobal0X128() external view returns (uint256);\r\n\r\n     /// feeGrowthGlobal1X128 记录从创建到现在，每个流动性累计产生的 token1 的手续费\r\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\r\n    /// @dev This value can overflow the uint256\r\n    function feeGrowthGlobal1X128() external view returns (uint256);\r\n   \r\n    function getPosition(address owner) \r\n        external \r\n        view \r\n        returns(\r\n            uint128 _liquidity,\r\n            uint256 feeGrowthInside0LastX128,\r\n            uint256 feeGrowthInside1LastX128,\r\n            uint128 tokensOwed0,\r\n            uint128 tokensOwed1\r\n        );\r\n\r\n    event Mint(\r\n        address sender, \r\n        address indexed owner, \r\n        uint128 amount,\r\n        uint256 amount0, \r\n        uint256 amount1);\r\n\r\n    function mint(address recipent, uint128 amount, bytes calldata data) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    event Collect(\r\n        address indexed owner, \r\n        address recipient,\r\n        uint256 amount0, \r\n        uint256 amount1);\r\n\r\n    function collect(\r\n        address recipient,\r\n        uint128 amount0Requested,\r\n        uint128 amount1Requested\r\n    ) external returns (uint128 amount0, uint128 amount1);\r\n\r\n    event Burn(\r\n        address indexed owner, \r\n        uint128 amount,\r\n        uint256 amount0, \r\n        uint256 amount1);\r\n\r\n    function burn(uint128 amount) external returns (uint256 amount0, uint256 amount1);\r\n\r\n    event Swap(\r\n        address indexed sender, \r\n        address indexed recipient,\r\n        int256 amount0, \r\n        int256 amount1, \r\n        uint160 sqrtPriceX96,\r\n        uint128 liquidity,\r\n        int24 tick);\r\n\r\n    function swap(address recipient, bool zeroForOne, int256 amountSpecified, uint160 sqrtPriceLimitX96, bytes calldata data)\r\n    external returns (int256 amount0, int256 amount1);\r\n\r\n   \r\n}"
    },
    "contracts/interfaces/IPoolManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./IFactory.sol\";\r\n\r\ninterface IPoolManager is IFactory {\r\n    struct PoolInfo {\r\n        address pool;\r\n        address token0;\r\n        address token1;\r\n        uint32 index;\r\n        uint24 fee;\r\n        uint8 feeProtocol;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        int24 tick;\r\n        uint160 sqrtPriceX96;\r\n        uint128 liquidity;\r\n    }\r\n\r\n    struct Pair{\r\n        address token0;\r\n        address token1;\r\n    }\r\n\r\n    function getPairs() external view returns (Pair[] memory);\r\n\r\n    function getAllPools() external view returns (PoolInfo[] memory poolsInfo);\r\n\r\n    struct CreateAndInitializeParams{\r\n        address token0;\r\n        address token1;\r\n        uint24 fee;\r\n        int24 tickLower;\r\n        int24 tickUpper;\r\n        uint160 sqrtPriceX96;\r\n    }\r\n\r\n    function createAndInitializePoolIfNecessary(CreateAndInitializeParams calldata params) external payable \r\n        returns (address pool);\r\n}"
    },
    "contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\n/// @author Solady (https://github.com/Vectorized/solady/blob/8200a70e8dc2a77ecb074fc2e99a2a0d36547522/src/utils/LibBit.sol)\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            r := shl(7, lt(0xffffffffffffffffffffffffffffffff, x))\n            r := or(r, shl(6, lt(0xffffffffffffffff, shr(r, x))))\n            r := or(r, shl(5, lt(0xffffffff, shr(r, x))))\n            r := or(r, shl(4, lt(0xffff, shr(r, x))))\n            r := or(r, shl(3, lt(0xff, shr(r, x))))\n            // forgefmt: disable-next-item\n            r := or(\n                r,\n                byte(\n                    and(\n                        0x1f,\n                        shr(shr(r, x), 0x8421084210842108cc6318c6db6d54be)\n                    ),\n                    0x0706060506020500060203020504000106050205030304010505030400000000\n                )\n            )\n        }\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        assembly (\"memory-safe\") {\n            // Isolate the least significant bit.\n            x := and(x, sub(0, x))\n            // For the upper 3 bits of the result, use a De Bruijn-like lookup.\n            // Credit to adhusson: https://blog.adhusson.com/cheap-find-first-set-evm/\n            // forgefmt: disable-next-item\n            r := shl(\n                5,\n                shr(\n                    252,\n                    shl(\n                        shl(\n                            2,\n                            shr(\n                                250,\n                                mul(\n                                    x,\n                                    0xb6db6db6ddddddddd34d34d349249249210842108c6318c639ce739cffffffff\n                                )\n                            )\n                        ),\n                        0x8040405543005266443200005020610674053026020000107506200176117077\n                    )\n                )\n            )\n            // For the lower 5 bits of the result, use a De Bruijn lookup.\n            // forgefmt: disable-next-item\n            r := or(\n                r,\n                byte(\n                    and(div(0xd76453e0, shr(r, x)), 0x1f),\n                    0x001f0d1e100c1d070f090b19131c1706010e11080a1a141802121b1503160405\n                )\n            )\n        }\n    }\n}\n"
    },
    "contracts/libraries/CustomRevert.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Library for reverting with custom errors efficiently\n/// @notice Contains functions for reverting with custom errors with different argument types efficiently\n/// @dev To use this library, declare `using CustomRevert for bytes4;` and replace `revert CustomError()` with\n/// `CustomError.selector.revertWith()`\n/// @dev The functions may tamper with the free memory pointer but it is fine since the call context is exited immediately\nlibrary CustomRevert {\n    /// @dev Reverts with the selector of a custom error in the scratch space\n    function revertWith(bytes4 selector) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            revert(0, 0x04)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an address argument in the scratch space\n    function revertWith(bytes4 selector, address addr) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(addr, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with an int24 argument in the scratch space\n    function revertWith(bytes4 selector, int24 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, signextend(2, value))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with a uint160 argument in the scratch space\n    function revertWith(bytes4 selector, uint160 value) internal pure {\n        assembly (\"memory-safe\") {\n            mstore(0, selector)\n            mstore(0x04, and(value, 0xffffffffffffffffffffffffffffffffffffffff))\n            revert(0, 0x24)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two int24 arguments\n    function revertWith(\n        bytes4 selector,\n        int24 value1,\n        int24 value2\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), signextend(2, value1))\n            mstore(add(fmp, 0x24), signextend(2, value2))\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two uint160 arguments\n    function revertWith(\n        bytes4 selector,\n        uint160 value1,\n        uint160 value2\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(\n                add(fmp, 0x04),\n                and(value1, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(fmp, 0x24),\n                and(value2, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @dev Reverts with a custom error with two address arguments\n    function revertWith(\n        bytes4 selector,\n        address value1,\n        address value2\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let fmp := mload(0x40)\n            mstore(fmp, selector)\n            mstore(\n                add(fmp, 0x04),\n                and(value1, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            mstore(\n                add(fmp, 0x24),\n                and(value2, 0xffffffffffffffffffffffffffffffffffffffff)\n            )\n            revert(fmp, 0x44)\n        }\n    }\n\n    /// @notice bubble up the revert message returned by a call and revert with the selector provided\n    /// @dev this function should only be used with custom errors of the type `CustomError(address target, bytes revertReason)`\n    function bubbleUpAndRevertWith(\n        bytes4 selector,\n        address addr\n    ) internal pure {\n        assembly (\"memory-safe\") {\n            let size := returndatasize()\n            let fmp := mload(0x40)\n\n            // Encode selector, address, offset, size, data\n            mstore(fmp, selector)\n            mstore(add(fmp, 0x04), addr)\n            mstore(add(fmp, 0x24), 0x40)\n            mstore(add(fmp, 0x44), size)\n            returndatacopy(add(fmp, 0x64), 0, size)\n\n            // Ensure the size is a multiple of 32 bytes\n            let encodedSize := add(0x64, mul(div(add(size, 31), 32), 32))\n            revert(fmp, encodedSize)\n        }\n    }\n}\n"
    },
    "contracts/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/libraries/FullMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contains 512-bit math functions\n/// @notice Facilitates multiplication and division that can have overflow of an intermediate value without any loss of precision\n/// @dev Handles \"phantom overflow\" i.e., allows multiplication and division where an intermediate value overflows 256 bits\nlibrary FullMath {\n    /// @notice Calculates floor(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    /// @dev Credit to Remco Bloemen under MIT license https://xn--2-umb.com/21/muldiv\n    function mulDiv(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = a * b\n            // Compute the product mod 2**256 and mod 2**256 - 1\n            // then use the Chinese Remainder Theorem to reconstruct\n            // the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2**256 + prod0\n            uint256 prod0 = a * b; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly (\"memory-safe\") {\n                let mm := mulmod(a, b, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Make sure the result is less than 2**256.\n            // Also prevents denominator == 0\n            require(denominator > prod1);\n\n            // Handle non-overflow cases, 256 by 256 division\n            if (prod1 == 0) {\n                assembly (\"memory-safe\") {\n                    result := div(prod0, denominator)\n                }\n                return result;\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0]\n            // Compute remainder using mulmod\n            uint256 remainder;\n            assembly (\"memory-safe\") {\n                remainder := mulmod(a, b, denominator)\n            }\n            // Subtract 256 bit number from 512 bit number\n            assembly (\"memory-safe\") {\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator\n            // Compute largest power of two divisor of denominator.\n            // Always >= 1.\n            uint256 twos = (0 - denominator) & denominator;\n            // Divide denominator by power of two\n            assembly (\"memory-safe\") {\n                denominator := div(denominator, twos)\n            }\n\n            // Divide [prod1 prod0] by the factors of two\n            assembly (\"memory-safe\") {\n                prod0 := div(prod0, twos)\n            }\n            // Shift in bits from prod1 into prod0. For this we need\n            // to flip `twos` such that it is 2**256 / twos.\n            // If twos is zero, then it becomes one\n            assembly (\"memory-safe\") {\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2**256\n            // Now that denominator is an odd number, it has an inverse\n            // modulo 2**256 such that denominator * inv = 1 mod 2**256.\n            // Compute the inverse by starting with a seed that is correct\n            // correct for four bits. That is, denominator * inv = 1 mod 2**4\n            uint256 inv = (3 * denominator) ^ 2;\n            // Now use Newton-Raphson iteration to improve the precision.\n            // Thanks to Hensel's lifting lemma, this also works in modular\n            // arithmetic, doubling the correct bits in each step.\n            inv *= 2 - denominator * inv; // inverse mod 2**8\n            inv *= 2 - denominator * inv; // inverse mod 2**16\n            inv *= 2 - denominator * inv; // inverse mod 2**32\n            inv *= 2 - denominator * inv; // inverse mod 2**64\n            inv *= 2 - denominator * inv; // inverse mod 2**128\n            inv *= 2 - denominator * inv; // inverse mod 2**256\n\n            // Because the division is now exact we can divide by multiplying\n            // with the modular inverse of denominator. This will give us the\n            // correct result modulo 2**256. Since the preconditions guarantee\n            // that the outcome is less than 2**256, this is the final result.\n            // We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inv;\n            return result;\n        }\n    }\n\n    /// @notice Calculates ceil(a×b÷denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n    /// @param a The multiplicand\n    /// @param b The multiplier\n    /// @param denominator The divisor\n    /// @return result The 256-bit result\n    function mulDivRoundingUp(\n        uint256 a,\n        uint256 b,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            result = mulDiv(a, b, denominator);\n            if (mulmod(a, b, denominator) != 0) {\n                require(++result > 0);\n            }\n        }\n    }\n}\n"
    },
    "contracts/libraries/LiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n"
    },
    "contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2 ** 255);\n        z = int256(y);\n    }\n}\n"
    },
    "contracts/libraries/SqrtPriceMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./LowGasSafeMath.sol\";\nimport \"./SafeCast.sol\";\n\nimport \"./FullMath.sol\";\nimport \"./UnsafeMath.sol\";\nimport \"./FixedPoint96.sol\";\n\n/// @title Functions based on Q64.96 sqrt price and liquidity\n/// @notice Contains the math that uses square root of price as a Q64.96 and liquidity to compute deltas\nlibrary SqrtPriceMath {\n    using LowGasSafeMath for uint256;\n    using SafeCast for uint256;\n\n    /// @notice Gets the next sqrt price given a delta of token0\n    /// @dev Always rounds up, because in the exact output case (increasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (decreasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The most precise formula for this is liquidity * sqrtPX96 / (liquidity +- amount * sqrtPX96),\n    /// if this is impossible because of overflow, we calculate liquidity / (liquidity / sqrtPX96 +- amount).\n    /// @param sqrtPX96 The starting price, i.e. before accounting for the token0 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token0 to add or remove from virtual reserves\n    /// @param add Whether to add or remove the amount of token0\n    /// @return The price after adding or removing amount, depending on add\n    function getNextSqrtPriceFromAmount0RoundingUp(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // we short circuit amount == 0 because the result is otherwise not guaranteed to equal the input price\n        if (amount == 0) return sqrtPX96;\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n\n        if (add) {\n            uint256 product;\n            if ((product = amount * sqrtPX96) / amount == sqrtPX96) {\n                uint256 denominator = numerator1 + product;\n                if (denominator >= numerator1)\n                    // always fits in 160 bits\n                    return\n                        uint160(\n                            FullMath.mulDivRoundingUp(\n                                numerator1,\n                                sqrtPX96,\n                                denominator\n                            )\n                        );\n            }\n\n            return\n                uint160(\n                    UnsafeMath.divRoundingUp(\n                        numerator1,\n                        (numerator1 / sqrtPX96).add(amount)\n                    )\n                );\n        } else {\n            uint256 product;\n            // if the product overflows, we know the denominator underflows\n            // in addition, we must check that the denominator does not underflow\n            require(\n                (product = amount * sqrtPX96) / amount == sqrtPX96 &&\n                    numerator1 > product\n            );\n            uint256 denominator = numerator1 - product;\n            return\n                FullMath\n                    .mulDivRoundingUp(numerator1, sqrtPX96, denominator)\n                    .toUint160();\n        }\n    }\n\n    /// @notice Gets the next sqrt price given a delta of token1\n    /// @dev Always rounds down, because in the exact output case (decreasing price) we need to move the price at least\n    /// far enough to get the desired output amount, and in the exact input case (increasing price) we need to move the\n    /// price less in order to not send too much output.\n    /// The formula we compute is within <1 wei of the lossless version: sqrtPX96 +- amount / liquidity\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the token1 delta\n    /// @param liquidity The amount of usable liquidity\n    /// @param amount How much of token1 to add, or remove, from virtual reserves\n    /// @param add Whether to add, or remove, the amount of token1\n    /// @return The price after adding or removing `amount`\n    function getNextSqrtPriceFromAmount1RoundingDown(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amount,\n        bool add\n    ) internal pure returns (uint160) {\n        // if we're adding (subtracting), rounding down requires rounding the quotient down (up)\n        // in both cases, avoid a mulDiv for most inputs\n        if (add) {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? (amount << FixedPoint96.RESOLUTION) / liquidity\n                    : FullMath.mulDiv(amount, FixedPoint96.Q96, liquidity)\n            );\n\n            return uint256(sqrtPX96).add(quotient).toUint160();\n        } else {\n            uint256 quotient = (\n                amount <= type(uint160).max\n                    ? UnsafeMath.divRoundingUp(\n                        amount << FixedPoint96.RESOLUTION,\n                        liquidity\n                    )\n                    : FullMath.mulDivRoundingUp(\n                        amount,\n                        FixedPoint96.Q96,\n                        liquidity\n                    )\n            );\n\n            require(sqrtPX96 > quotient);\n            // always fits 160 bits\n            return uint160(sqrtPX96 - quotient);\n        }\n    }\n\n    /// @notice Gets the next sqrt price given an input amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0, or if the next price is out of bounds\n    /// @param sqrtPX96 The starting price, i.e., before accounting for the input amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountIn How much of token0, or token1, is being swapped in\n    /// @param zeroForOne Whether the amount in is token0 or token1\n    /// @return sqrtQX96 The price after adding the input amount to token0 or token1\n    function getNextSqrtPriceFromInput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountIn,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we don't pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount0RoundingUp(\n                    sqrtPX96,\n                    liquidity,\n                    amountIn,\n                    true\n                )\n                : getNextSqrtPriceFromAmount1RoundingDown(\n                    sqrtPX96,\n                    liquidity,\n                    amountIn,\n                    true\n                );\n    }\n\n    /// @notice Gets the next sqrt price given an output amount of token0 or token1\n    /// @dev Throws if price or liquidity are 0 or the next price is out of bounds\n    /// @param sqrtPX96 The starting price before accounting for the output amount\n    /// @param liquidity The amount of usable liquidity\n    /// @param amountOut How much of token0, or token1, is being swapped out\n    /// @param zeroForOne Whether the amount out is token0 or token1\n    /// @return sqrtQX96 The price after removing the output amount of token0 or token1\n    function getNextSqrtPriceFromOutput(\n        uint160 sqrtPX96,\n        uint128 liquidity,\n        uint256 amountOut,\n        bool zeroForOne\n    ) internal pure returns (uint160 sqrtQX96) {\n        require(sqrtPX96 > 0);\n        require(liquidity > 0);\n\n        // round to make sure that we pass the target price\n        return\n            zeroForOne\n                ? getNextSqrtPriceFromAmount1RoundingDown(\n                    sqrtPX96,\n                    liquidity,\n                    amountOut,\n                    false\n                )\n                : getNextSqrtPriceFromAmount0RoundingUp(\n                    sqrtPX96,\n                    liquidity,\n                    amountOut,\n                    false\n                );\n    }\n\n    /// @notice Gets the amount0 delta between two prices\n    /// @dev Calculates liquidity / sqrt(lower) - liquidity / sqrt(upper),\n    /// i.e. liquidity * (sqrt(upper) - sqrt(lower)) / (sqrt(upper) * sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up or down\n    /// @return amount0 Amount of token0 required to cover a position of size liquidity between the two passed prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount0) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        uint256 numerator1 = uint256(liquidity) << FixedPoint96.RESOLUTION;\n        uint256 numerator2 = sqrtRatioBX96 - sqrtRatioAX96;\n\n        require(sqrtRatioAX96 > 0);\n\n        return\n            roundUp\n                ? UnsafeMath.divRoundingUp(\n                    FullMath.mulDivRoundingUp(\n                        numerator1,\n                        numerator2,\n                        sqrtRatioBX96\n                    ),\n                    sqrtRatioAX96\n                )\n                : FullMath.mulDiv(numerator1, numerator2, sqrtRatioBX96) /\n                    sqrtRatioAX96;\n    }\n\n    /// @notice Gets the amount1 delta between two prices\n    /// @dev Calculates liquidity * (sqrt(upper) - sqrt(lower))\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The amount of usable liquidity\n    /// @param roundUp Whether to round the amount up, or down\n    /// @return amount1 Amount of token1 required to cover a position of size liquidity between the two passed prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        uint128 liquidity,\n        bool roundUp\n    ) internal pure returns (uint256 amount1) {\n        if (sqrtRatioAX96 > sqrtRatioBX96)\n            (sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);\n\n        return\n            roundUp\n                ? FullMath.mulDivRoundingUp(\n                    liquidity,\n                    sqrtRatioBX96 - sqrtRatioAX96,\n                    FixedPoint96.Q96\n                )\n                : FullMath.mulDiv(\n                    liquidity,\n                    sqrtRatioBX96 - sqrtRatioAX96,\n                    FixedPoint96.Q96\n                );\n    }\n\n    /// @notice Helper that gets signed token0 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount0 delta\n    /// @return amount0 Amount of token0 corresponding to the passed liquidityDelta between the two prices\n    function getAmount0Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount0) {\n        return\n            liquidity < 0\n                ? -getAmount0Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(-liquidity),\n                    false\n                ).toInt256()\n                : getAmount0Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(liquidity),\n                    true\n                ).toInt256();\n    }\n\n    /// @notice Helper that gets signed token1 delta\n    /// @param sqrtRatioAX96 A sqrt price\n    /// @param sqrtRatioBX96 Another sqrt price\n    /// @param liquidity The change in liquidity for which to compute the amount1 delta\n    /// @return amount1 Amount of token1 corresponding to the passed liquidityDelta between the two prices\n    function getAmount1Delta(\n        uint160 sqrtRatioAX96,\n        uint160 sqrtRatioBX96,\n        int128 liquidity\n    ) internal pure returns (int256 amount1) {\n        return\n            liquidity < 0\n                ? -getAmount1Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(-liquidity),\n                    false\n                ).toInt256()\n                : getAmount1Delta(\n                    sqrtRatioAX96,\n                    sqrtRatioBX96,\n                    uint128(liquidity),\n                    true\n                ).toInt256();\n    }\n}\n"
    },
    "contracts/libraries/SwapMath.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity >=0.5.0;\n\nimport \"./FullMath.sol\";\nimport \"./SqrtPriceMath.sol\";\n\n/// @title Computes the result of a swap within ticks\n/// @notice Contains methods for computing the result of a swap within a single tick price range, i.e., a single tick.\nlibrary SwapMath {\n    /// @notice Computes the result of swapping some amount in, or amount out, given the parameters of the swap\n    /// @dev The fee, plus the amount in, will never exceed the amount remaining if the swap's `amountSpecified` is positive\n    /// @param sqrtRatioCurrentX96 The current sqrt price of the pool\n    /// @param sqrtRatioTargetX96 The price that cannot be exceeded, from which the direction of the swap is inferred\n    /// @param liquidity The usable liquidity\n    /// @param amountRemaining How much input or output amount is remaining to be swapped in/out\n    /// @param feePips The fee taken from the input amount, expressed in hundredths of a bip\n    /// @return sqrtRatioNextX96 The price after swapping the amount in/out, not to exceed the price target\n    /// @return amountIn The amount to be swapped in, of either token0 or token1, based on the direction of the swap\n    /// @return amountOut The amount to be received, of either token0 or token1, based on the direction of the swap\n    /// @return feeAmount The amount of input that will be taken as a fee\n    function computeSwapStep(\n        uint160 sqrtRatioCurrentX96,\n        uint160 sqrtRatioTargetX96,\n        uint128 liquidity,\n        int256 amountRemaining,\n        uint24 feePips\n    )\n        internal\n        pure\n        returns (\n            uint160 sqrtRatioNextX96,\n            uint256 amountIn,\n            uint256 amountOut,\n            uint256 feeAmount\n        )\n    {\n        bool zeroForOne = sqrtRatioCurrentX96 >= sqrtRatioTargetX96;\n        bool exactIn = amountRemaining >= 0;\n\n        if (exactIn) {\n            uint256 amountRemainingLessFee = FullMath.mulDiv(\n                uint256(amountRemaining),\n                1e6 - feePips,\n                1e6\n            );\n            amountIn = zeroForOne\n                ? SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioTargetX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    true\n                )\n                : SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioTargetX96,\n                    liquidity,\n                    true\n                );\n            if (amountRemainingLessFee >= amountIn)\n                sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromInput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    amountRemainingLessFee,\n                    zeroForOne\n                );\n        } else {\n            amountOut = zeroForOne\n                ? SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioTargetX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    false\n                )\n                : SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioTargetX96,\n                    liquidity,\n                    false\n                );\n            if (uint256(-amountRemaining) >= amountOut)\n                sqrtRatioNextX96 = sqrtRatioTargetX96;\n            else\n                sqrtRatioNextX96 = SqrtPriceMath.getNextSqrtPriceFromOutput(\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    uint256(-amountRemaining),\n                    zeroForOne\n                );\n        }\n\n        bool max = sqrtRatioTargetX96 == sqrtRatioNextX96;\n\n        // get the input/output amounts\n        if (zeroForOne) {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioNextX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    true\n                );\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioNextX96,\n                    sqrtRatioCurrentX96,\n                    liquidity,\n                    false\n                );\n        } else {\n            amountIn = max && exactIn\n                ? amountIn\n                : SqrtPriceMath.getAmount1Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioNextX96,\n                    liquidity,\n                    true\n                );\n            amountOut = max && !exactIn\n                ? amountOut\n                : SqrtPriceMath.getAmount0Delta(\n                    sqrtRatioCurrentX96,\n                    sqrtRatioNextX96,\n                    liquidity,\n                    false\n                );\n        }\n\n        // cap the output amount to not exceed the remaining output amount\n        if (!exactIn && amountOut > uint256(-amountRemaining)) {\n            amountOut = uint256(-amountRemaining);\n        }\n\n        if (exactIn && sqrtRatioNextX96 != sqrtRatioTargetX96) {\n            // we didn't reach the target, so take the remainder of the maximum input as fee\n            feeAmount = uint256(amountRemaining) - amountIn;\n        } else {\n            feeAmount = FullMath.mulDivRoundingUp(\n                amountIn,\n                feePips,\n                1e6 - feePips\n            );\n        }\n    }\n}\n"
    },
    "contracts/libraries/TickMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity ^0.8.0;\n\nimport {BitMath} from \"./BitMath.sol\";\nimport {CustomRevert} from \"./CustomRevert.sol\";\n\n/// @title Math library for computing sqrt prices from ticks and vice versa\n/// @notice Computes sqrt price for ticks of size 1.0001, i.e. sqrt(1.0001^tick) as fixed point Q64.96 numbers. Supports\n/// prices between 2**-128 and 2**128\nlibrary TickMath {\n    using CustomRevert for bytes4;\n\n    /// @notice Thrown when the tick passed to #getSqrtPriceAtTick is not between MIN_TICK and MAX_TICK\n    error InvalidTick(int24 tick);\n    /// @notice Thrown when the price passed to #getTickAtSqrtPrice does not correspond to a price between MIN_TICK and MAX_TICK\n    error InvalidSqrtPrice(uint160 sqrtPriceX96);\n\n    /// @dev The minimum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**-128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MIN_TICK = -887272;\n    /// @dev The maximum tick that may be passed to #getSqrtPriceAtTick computed from log base 1.0001 of 2**128\n    /// @dev If ever MIN_TICK and MAX_TICK are not centered around 0, the absTick logic in getSqrtPriceAtTick cannot be used\n    int24 internal constant MAX_TICK = 887272;\n\n    /// @dev The minimum tick spacing value drawn from the range of type int16 that is greater than 0, i.e. min from the range [1, 32767]\n    int24 internal constant MIN_TICK_SPACING = 1;\n    /// @dev The maximum tick spacing value drawn from the range of type int16, i.e. max from the range [1, 32767]\n    int24 internal constant MAX_TICK_SPACING = type(int16).max;\n\n    /// @dev The minimum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MIN_TICK)\n    uint160 internal constant MIN_SQRT_PRICE = 4295128739;\n    /// @dev The maximum value that can be returned from #getSqrtPriceAtTick. Equivalent to getSqrtPriceAtTick(MAX_TICK)\n    uint160 internal constant MAX_SQRT_PRICE =\n        1461446703485210103287273052203988822378723970342;\n    /// @dev A threshold used for optimized bounds check, equals `MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1`\n    uint160 internal constant MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE =\n        1461446703485210103287273052203988822378723970342 - 4295128739 - 1;\n\n    /// @notice Given a tickSpacing, compute the maximum usable tick\n    function maxUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MAX_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Given a tickSpacing, compute the minimum usable tick\n    function minUsableTick(int24 tickSpacing) internal pure returns (int24) {\n        unchecked {\n            return (MIN_TICK / tickSpacing) * tickSpacing;\n        }\n    }\n\n    /// @notice Calculates sqrt(1.0001^tick) * 2^96\n    /// @dev Throws if |tick| > max tick\n    /// @param tick The input tick for the above formula\n    /// @return sqrtPriceX96 A Fixed point Q64.96 number representing the sqrt of the price of the two assets (currency1/currency0)\n    /// at the given tick\n    function getSqrtPriceAtTick(\n        int24 tick\n    ) internal pure returns (uint160 sqrtPriceX96) {\n        unchecked {\n            uint256 absTick;\n            assembly (\"memory-safe\") {\n                tick := signextend(2, tick)\n                // mask = 0 if tick >= 0 else -1 (all 1s)\n                let mask := sar(255, tick)\n                // if tick >= 0, |tick| = tick = 0 ^ tick\n                // if tick < 0, |tick| = ~~|tick| = ~(-|tick| - 1) = ~(tick - 1) = (-1) ^ (tick - 1)\n                // either way, |tick| = mask ^ (tick + mask)\n                absTick := xor(mask, add(mask, tick))\n            }\n\n            if (absTick > uint256(int256(MAX_TICK)))\n                InvalidTick.selector.revertWith(tick);\n\n            // The tick is decomposed into bits, and for each bit with index i that is set, the product of 1/sqrt(1.0001^(2^i))\n            // is calculated (using Q128.128). The constants used for this calculation are rounded to the nearest integer\n\n            // Equivalent to:\n            //     price = absTick & 0x1 != 0 ? 0xfffcb933bd6fad37aa2d162d1a594001 : 0x100000000000000000000000000000000;\n            //     or price = int(2**128 / sqrt(1.0001)) if (absTick & 0x1) else 1 << 128\n            uint256 price;\n            assembly (\"memory-safe\") {\n                price := xor(\n                    shl(128, 1),\n                    mul(\n                        xor(shl(128, 1), 0xfffcb933bd6fad37aa2d162d1a594001),\n                        and(absTick, 0x1)\n                    )\n                )\n            }\n            if (absTick & 0x2 != 0)\n                price = (price * 0xfff97272373d413259a46990580e213a) >> 128;\n            if (absTick & 0x4 != 0)\n                price = (price * 0xfff2e50f5f656932ef12357cf3c7fdcc) >> 128;\n            if (absTick & 0x8 != 0)\n                price = (price * 0xffe5caca7e10e4e61c3624eaa0941cd0) >> 128;\n            if (absTick & 0x10 != 0)\n                price = (price * 0xffcb9843d60f6159c9db58835c926644) >> 128;\n            if (absTick & 0x20 != 0)\n                price = (price * 0xff973b41fa98c081472e6896dfb254c0) >> 128;\n            if (absTick & 0x40 != 0)\n                price = (price * 0xff2ea16466c96a3843ec78b326b52861) >> 128;\n            if (absTick & 0x80 != 0)\n                price = (price * 0xfe5dee046a99a2a811c461f1969c3053) >> 128;\n            if (absTick & 0x100 != 0)\n                price = (price * 0xfcbe86c7900a88aedcffc83b479aa3a4) >> 128;\n            if (absTick & 0x200 != 0)\n                price = (price * 0xf987a7253ac413176f2b074cf7815e54) >> 128;\n            if (absTick & 0x400 != 0)\n                price = (price * 0xf3392b0822b70005940c7a398e4b70f3) >> 128;\n            if (absTick & 0x800 != 0)\n                price = (price * 0xe7159475a2c29b7443b29c7fa6e889d9) >> 128;\n            if (absTick & 0x1000 != 0)\n                price = (price * 0xd097f3bdfd2022b8845ad8f792aa5825) >> 128;\n            if (absTick & 0x2000 != 0)\n                price = (price * 0xa9f746462d870fdf8a65dc1f90e061e5) >> 128;\n            if (absTick & 0x4000 != 0)\n                price = (price * 0x70d869a156d2a1b890bb3df62baf32f7) >> 128;\n            if (absTick & 0x8000 != 0)\n                price = (price * 0x31be135f97d08fd981231505542fcfa6) >> 128;\n            if (absTick & 0x10000 != 0)\n                price = (price * 0x9aa508b5b7a84e1c677de54f3e99bc9) >> 128;\n            if (absTick & 0x20000 != 0)\n                price = (price * 0x5d6af8dedb81196699c329225ee604) >> 128;\n            if (absTick & 0x40000 != 0)\n                price = (price * 0x2216e584f5fa1ea926041bedfe98) >> 128;\n            if (absTick & 0x80000 != 0)\n                price = (price * 0x48a170391f7dc42444e8fa2) >> 128;\n\n            assembly (\"memory-safe\") {\n                // if (tick > 0) price = type(uint256).max / price;\n                if sgt(tick, 0) {\n                    price := div(not(0), price)\n                }\n\n                // this divides by 1<<32 rounding up to go from a Q128.128 to a Q128.96.\n                // we then downcast because we know the result always fits within 160 bits due to our tick input constraint\n                // we round up in the division so getTickAtSqrtPrice of the output price is always consistent\n                // `sub(shl(32, 1), 1)` is `type(uint32).max`\n                // `price + type(uint32).max` will not overflow because `price` fits in 192 bits\n                sqrtPriceX96 := shr(32, add(price, sub(shl(32, 1), 1)))\n            }\n        }\n    }\n\n    /// @notice Calculates the greatest tick value such that getSqrtPriceAtTick(tick) <= sqrtPriceX96\n    /// @dev Throws in case sqrtPriceX96 < MIN_SQRT_PRICE, as MIN_SQRT_PRICE is the lowest value getSqrtPriceAtTick may\n    /// ever return.\n    /// @param sqrtPriceX96 The sqrt price for which to compute the tick as a Q64.96\n    /// @return tick The greatest tick for which the getSqrtPriceAtTick(tick) is less than or equal to the input sqrtPriceX96\n    function getTickAtSqrtPrice(\n        uint160 sqrtPriceX96\n    ) internal pure returns (int24 tick) {\n        unchecked {\n            // Equivalent: if (sqrtPriceX96 < MIN_SQRT_PRICE || sqrtPriceX96 >= MAX_SQRT_PRICE) revert InvalidSqrtPrice();\n            // second inequality must be >= because the price can never reach the price at the max tick\n            // if sqrtPriceX96 < MIN_SQRT_PRICE, the `sub` underflows and `gt` is true\n            // if sqrtPriceX96 >= MAX_SQRT_PRICE, sqrtPriceX96 - MIN_SQRT_PRICE > MAX_SQRT_PRICE - MIN_SQRT_PRICE - 1\n            if (\n                (sqrtPriceX96 - MIN_SQRT_PRICE) >\n                MAX_SQRT_PRICE_MINUS_MIN_SQRT_PRICE_MINUS_ONE\n            ) {\n                InvalidSqrtPrice.selector.revertWith(sqrtPriceX96);\n            }\n\n            uint256 price = uint256(sqrtPriceX96) << 32;\n\n            uint256 r = price;\n            uint256 msb = BitMath.mostSignificantBit(r);\n\n            if (msb >= 128) r = price >> (msb - 127);\n            else r = price << (127 - msb);\n\n            int256 log_2 = (int256(msb) - 128) << 64;\n\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(63, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(62, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(61, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(60, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(59, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(58, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(57, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(56, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(55, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(54, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(53, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(52, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(51, f))\n                r := shr(f, r)\n            }\n            assembly (\"memory-safe\") {\n                r := shr(127, mul(r, r))\n                let f := shr(128, r)\n                log_2 := or(log_2, shl(50, f))\n            }\n\n            int256 log_sqrt10001 = log_2 * 255738958999603826347141; // Q22.128 number\n\n            // Magic number represents the ceiling of the maximum value of the error when approximating log_sqrt10001(x)\n            int24 tickLow = int24(\n                (log_sqrt10001 - 3402992956809132418596140100660247210) >> 128\n            );\n\n            // Magic number represents the minimum value of the error when approximating log_sqrt10001(x), when\n            // sqrtPrice is from the range (2^-64, 2^64). This is safe as MIN_SQRT_PRICE is more than 2^-64. If MIN_SQRT_PRICE\n            // is changed, this may need to be changed too\n            int24 tickHi = int24(\n                (log_sqrt10001 + 291339464771989622907027621153398088495) >> 128\n            );\n\n            tick = tickLow == tickHi\n                ? tickLow\n                : getSqrtPriceAtTick(tickHi) <= sqrtPriceX96\n                ? tickHi\n                : tickLow;\n        }\n    }\n}\n"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.6.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title TransferHelper\n/// @notice Contains helper methods for interacting with ERC20 tokens that do not consistently return true/false\nlibrary TransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Calls transfer on token contract, errors with TF if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(address token, address to, uint256 value) internal {\n        (bool success, bytes memory data) = token.call(\n            abi.encodeWithSelector(IERC20.transfer.selector, to, value)\n        );\n        require(\n            success && (data.length == 0 || abi.decode(data, (bool))),\n            \"TF\"\n        );\n    }\n}\n"
    },
    "contracts/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
    },
    "contracts/Pool.sol": {
      "content": "//SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\nimport \"./libraries/SqrtPriceMath.sol\";\nimport \"./libraries/TickMath.sol\";\nimport \"./libraries/LiquidityMath.sol\";\nimport \"./libraries/LowGasSafeMath.sol\";\nimport \"./libraries/TransferHelper.sol\";\nimport \"./libraries/SafeCast.sol\";\nimport \"./libraries/FullMath.sol\";\nimport \"./libraries/FixedPoint128.sol\";\nimport \"./libraries/SwapMath.sol\";\n\nimport \"./interfaces/IFactory.sol\";\nimport \"./interfaces/IPool.sol\";\n\n//MetaSwap每个代币对可能有多个 Pool 合约，每个 Pool 合约就是一个交易池，每个交易池都有自己的价格上下限和手续费\n//Uniswap 的交易池只有交易对+手续费属性，而我们的交易池还有价格上下限属性。\n//在 Uniswap V3 中，你需要在一个交易池里面去管理在不同价格区间内的流动性\n//这里简化了 只需要考虑这个固定范围内的流动性管理和交易即可，\ncontract Pool is IPool {\n    using SafeCast for uint256;\n    using LowGasSafeMath for int256;\n    using LowGasSafeMath for uint256;\n\n    // ============ 不可变状态变量 ============\n    \n    address public immutable override factory;\n\n    address public immutable override token0;\n\n    address public immutable override token1;\n\n    uint24 public immutable override fee;\n\n    int24 public immutable override tickLower;\n\n    int24 public immutable override tickUpper;\n\n    // ============ 可变状态变量 ============\n    \n    uint160 public override sqrtPriceX96;\n\n    int24 public override tick;\n\n    uint128 public override liquidity;\n\n    uint256 public override feeGrowthGlobal0X128;\n\n    uint256 public override feeGrowthGlobal1X128;\n\n\n    /**\n     * @notice 流动性位置结构体\n     * @dev 存储每个地址的流动性位置信息\n     */\n    struct Position{\n        uint128 liquidity;// 该 Position 拥有的流动性\n        uint128 tokensOwed0;// 可提取的 token0 数量\n        uint128 tokensOwed1;// 可提取的 token1 数量\n        uint256 feeGrowthInside0LastX128;// 上次提取手续费时的 feeGrowthGlobal0X128\n        uint256 feeGrowthInside1LastX128;// 上次提取手续费是的 feeGrowthGlobal1X128\n    }\n    // 用一个 mapping 来存放所有 Position 的信息，key 是地址，value 是 Position 结构体\n    mapping(address => Position) public positions;\n    \n    /**\n     * @notice 构造函数 - 从Factory读取池参数\n     * @dev 使用CREATE2部署，参数通过Factory的parameters变量传递\n     */\n    constructor(){\n        // Factory 创建 Pool 时会通 new Pool{salt: salt}() 的方式创建 Pool 合约，\n        // 通过 salt 指定 Pool 的地址，这样其他地方也可以推算出 Pool 的地址\n        // 参数通过读取 Factory 合约的 parameters 获取\n        // 不通过构造函数传入，因为 CREATE2 会根据 \n        // initcode 计算出新地址（new_address = hash(0xFF, sender, salt, bytecode)），带上参数就不能计算出稳定的地址了\n        (factory, token0, token1, tickLower, tickUpper,fee) = IFactory(msg.sender).parameters();\n    }\n\n    /**\n     * @notice 初始化池的价格\n     * @param _sqrtPriceX96 初始价格的平方根（X96格式）\n     * @dev 只能初始化一次，价格必须在tick范围内\n    */\n    function initialize(uint160 _sqrtPriceX96) external override {\n        require(sqrtPriceX96 == 0, \"Already initialized\");\n         // 通过价格获取 tick，判断 tick 是否在 tickLower 和 tickUpper 之间\n        tick=TickMath.getTickAtSqrtPrice(_sqrtPriceX96);\n        require(tick >= tickLower && tick <= tickUpper, \"sqrtPriceX96 should be within the range of [tickLower, tickUpper)\");\n        // 初始化 Pool 的 sqrtPriceX96\n        sqrtPriceX96 = _sqrtPriceX96;\n    }\n\n    \n    struct ModifyPositionParams {\n         // the address that owns the position\n        address owner;\n        // any change in liquidity\n        int128 liquidityDelta;\n    }\n\n    // 添加流动性\n    // 添加流动性时，需要传入 amount 和 data，amount 是添加的流动性数量，data 是回调数据\n    // recipient 流动性的权益赋予谁\n    // return amount0 和 amount1 是添加流动性后需要多少 amount0 和 amount1\n    // 添加流动性后，需要回调 mintCallback 方法，这个方法需要传入 amount0 和 amount1，\n    function mint(address recipent,uint128 amount,bytes calldata data) \n        external override returns (uint256 amount0,uint256 amount1){\n            require(amount > 0, \"Amount must be greater than 0\");\n            // 基于 amount 计算出当前需要多少 amount0 和 amount1\n            (int256 amount0Int,int256 amount1Int) = _modifyPosition(ModifyPositionParams({owner: recipent, liquidityDelta: int128(amount)})\n            );\n            amount0=uint256(amount0Int);\n            amount1=uint256(amount1Int);\n            uint256 balance0Before;\n            uint256 balance1Before;\n            if (amount0 > 0) balance0Before=_balance0();\n            if (amount1 > 0) balance1Before=_balance1();\n            // 回调 mintCallback 调用 `mint` 方法的合约需要实现 `IMintCallback` 接口完成代币的转入操作：\n            IMintCallback(msg.sender).mintCallback(amount0, amount1, data);\n            //回调完成后会检查交易池合约的对应余额是否发生变化，并且增量应该大于 amount0 和 amount1：这意味着调用方确实转入了所需的资产。\n            if (amount0 > 0) {\n                require(balance0Before.add(amount0)<=_balance0(), \"M0\");\n            }\n            if (amount1 > 0) {\n                require(balance1Before.add(amount1)<=_balance1(), \"M1\");\n            }\n            // 触发 Mint 事件\n            emit Mint(msg.sender, recipent, amount, amount0, amount1);\n    }\n\n\n    //Uniswap V3 中，计算流动性时的上下限是参数动态传入的 params.tickLower 和 params.tickUpper\n    //MetaSwap 交易池都固定在一个价格区间内，mint 也只能在这个价格区间内 mint，所以 tickLower 和 tickUpper 是固定的\n    function _modifyPosition(ModifyPositionParams memory params) private returns(int256 amount0,int256 amount1){\n        // 通过新增的流动性计算 amount0 和 amount1\n        // 参考 UniswapV3 的代码\n        // 用到 SqrtPriceMath 库，这个库是 Uniswap V3 中的一个工具库\n        // FullMath.sol 和 TickMath.sol 因为依赖于 solidity <0.8.0;这里用的是 0.8.0+，所以我们使用 Uniswap V4 的代码\n        // 当前价格在一定在tick区间内，所以不需要考虑价格超出区间的情况\n        amount0=SqrtPriceMath.getAmount0Delta(sqrtPriceX96,TickMath.getSqrtPriceAtTick(tickUpper),params.liquidityDelta);\n        amount1=SqrtPriceMath.getAmount1Delta(sqrtPriceX96,TickMath.getSqrtPriceAtTick(tickLower),params.liquidityDelta);\n\n        // 获取当前用户的 position，recipient 应该改为 msg.sender\n        Position storage position = positions[params.owner];\n\n        //关键步骤：结算未领取的费用\n        //将费用增长因子差值乘以头寸原有的流动性数量，再除以 Q128（一个固定点数精度常量），得到应累加的费用代币数量。\n        uint128 tokensOwed0 = uint128(\n            FullMath.mulDiv(\n                feeGrowthGlobal0X128 - position.feeGrowthInside0LastX128,\n                position.liquidity,\n                FixedPoint128.Q128\n            )\n        );\n        uint128 tokensOwed1 = uint128(\n            FullMath.mulDiv(\n                feeGrowthGlobal1X128 - position.feeGrowthInside1LastX128,\n                position.liquidity,\n                FixedPoint128.Q128\n            )\n        );\n\n         // 更新提取手续费的记录，同步到当前最新的 feeGrowthGlobal0X128，代表都提取完了\n        position.feeGrowthInside0LastX128 = feeGrowthGlobal0X128;\n        position.feeGrowthInside1LastX128 = feeGrowthGlobal1X128;\n        // 把可以提取的手续费记录到 tokensOwed0 和 tokensOwed1 中\n        // LP 可以通过 collect 来最终提取到用户自己账户上\n        if (tokensOwed0 > 0 || tokensOwed1 > 0) {\n            position.tokensOwed0 += tokensOwed0;\n            position.tokensOwed1 += tokensOwed1;\n        }\n        // 修改池子 liquidity 和头寸 position.liquidity\n        liquidity=LiquidityMath.addDelta(liquidity,params.liquidityDelta);\n        position.liquidity=LiquidityMath.addDelta(position.liquidity,params.liquidityDelta);\n    }\n\n\n    //它不需要有回调，另外提取代币是放到 collect 中操作的。\n    //在 burn 方法中，我们只是把流动性移除，并计算出要退回给 LP 的 amount0 和 amount1，记录在合约状态中\n    function burn(uint128 amount) external override returns (uint256 amount0,uint256 amount1){\n        require(amount > 0, \"Burn Amount must be greater than 0\");\n        require(amount <=positions[msg.sender].liquidity,\"Burn amount exceeds liquidity\");\n        // 修改 positions 中的信息\n        (int256 amount0Int, int256 amount1Int) = _modifyPosition(\n            ModifyPositionParams({\n                owner: msg.sender,\n                liquidityDelta: -int128(amount)\n            })\n        );\n        // 获取燃烧后的退换的 amount0 和 amount1\n        amount0=uint256(-amount0Int);\n        amount1=uint256(-amount1Int);\n\n        if (amount0 > 0 || amount1 > 0) {\n            (\n                positions[msg.sender].tokensOwed0,\n                positions[msg.sender].tokensOwed1\n            ) = (\n                positions[msg.sender].tokensOwed0 + uint128(amount0),\n                positions[msg.sender].tokensOwed1 + uint128(amount1)\n            );\n        }\n\n        emit Burn(msg.sender, amount, amount0, amount1);\n    }\n\n    //Position 中定义了 tokensOwed0 和 tokensOwed1，\n    //用来记录 LP 可以提取的代币数量，这个代币数量是在 collect 中提取的\n     function collect(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external override returns (uint128 amount0, uint128 amount1) {\n        // 获取当前用户的 position\n        Position storage position = positions[msg.sender];\n        // 把钱退给用户 recipient\n        amount0 = amount0Requested > position.tokensOwed0\n            ? position.tokensOwed0\n            : amount0Requested;\n        amount1 = amount1Requested > position.tokensOwed1\n            ? position.tokensOwed1\n            : amount1Requested;\n\n        if (amount0 > 0) {\n            position.tokensOwed0 -= amount0;\n            TransferHelper.safeTransfer(token0, recipient, amount0);\n        }\n        if (amount1 > 0) {\n            position.tokensOwed1 -= amount1;\n            TransferHelper.safeTransfer(token1, recipient, amount1);\n        }\n        // 触发 Collect 事件\n        emit Collect(msg.sender, recipient, amount0, amount1);\n    }\n\n    // 交易中需要临时存储的变量\n    struct SwapParams {\n        // 剩余需要交换的数量\n        int256 amountSpecifiedRemaining;\n        // 已计算出的数量\n        int256 amountCalculated;\n        // 当前价格\n        uint160 sqrtPriceX96;\n         // 全局费用增长，根据方向选择 token0 或token1 的费用增长。\n        uint256 feeGrowthGlobalX128;\n        // 该交易中用户转入的 token 的数量\n        uint256 amountIn;\n         // 该交易中用户转出的 token 的数量\n        uint256 amountOut;\n        // 该交易中需要支付的手续费 如果 zeroForOne 是 ture，则是用户转入 token0，单位是 token0 的数量，反正是 token1 的数量\n        uint256 feeAmount;\n    }\n\n\n    //amountSpecified:指定的代币数量，指定输入的代币数量(要支付的 token0 的数量)则为正数，指定输出的代币(要获取的 token1)数量则为负数\n    //sqrtPriceLimitX96: 价格限制，如果从 token0 交换 token1 则限定价格下限，从 token1 交换 token0 则限定价格上限\n    //如果从 token0 交换 token1 则限定价格下限，从 token1 交换 token0 则限定价格上限\n    //data: 回调数据\n    function swap(\n        address recipient, \n        bool zeroForOne, \n        int256 amountSpecified,  \n        uint160 sqrtPriceLimitX96, \n        bytes calldata data) external override returns (int256 amount0, int256 amount1)\n        {\n        // 检查 amountSpecified 是否为 0\n        require(amountSpecified != 0, \"AS\");\n        // 对于 zeroForOne 方向，token0 换 token1,交易会导致池子的 token0 变多，\n        // 价格下跌，我们需要验证 sqrtPriceLimitX96 必须小于当前的价格，\n        // 对于 !zeroForOne 方向，价格限制必须高于当前价格但低于最大价格\n        require(\n            zeroForOne \n             ? sqrtPriceLimitX96 < sqrtPriceX96 && sqrtPriceLimitX96 > TickMath.MIN_SQRT_PRICE\n             : sqrtPriceLimitX96 > sqrtPriceX96 && sqrtPriceLimitX96 < TickMath.MAX_SQRT_PRICE,\n            \"SPL\"\n        );\n\n        bool exactInput=amountSpecified>0; //判断是输入还是输出模式\n        SwapParams memory state = SwapParams({\n            amountSpecifiedRemaining: amountSpecified,\n            amountCalculated: 0,\n            sqrtPriceX96: sqrtPriceX96,\n            feeGrowthGlobalX128: zeroForOne\n                ? feeGrowthGlobal0X128\n                : feeGrowthGlobal1X128,\n            amountIn: 0,\n            amountOut: 0,\n            feeAmount: 0\n        });\n        // 计算交易的上下限，基于 tick 计算价格\n        uint160 sqrtPriceX96Lower =TickMath.getSqrtPriceAtTick(tickLower);\n        uint160 sqrtPriceX96Upper =TickMath.getSqrtPriceAtTick(tickUpper);\n        // 计算用户交易价格的限制，如果是 zeroForOne 是 true，说明用户会换入 token0，\n        // 会压低 token0 的价格（也就是池子的价格），所以要限制最低价格不能超过 sqrtPriceX96Lower\n        uint160 sqrtPriceX96PoolLimit = zeroForOne\n            ? sqrtPriceX96Lower\n            : sqrtPriceX96Upper;\n        //  SwapMath.computeSwapStep 计算当前步骤的输入量、输出量、费用和新价格。\n        (state.sqrtPriceX96,state.amountIn,state.amountOut,state.feeAmount)=SwapMath.computeSwapStep(sqrtPriceX96,\n            (zeroForOne ? sqrtPriceX96PoolLimit < sqrtPriceLimitX96 : sqrtPriceX96PoolLimit > sqrtPriceLimitX96)\n            ?sqrtPriceLimitX96:sqrtPriceX96PoolLimit,\n            liquidity,\n            amountSpecified, // 第一次剩余需要交换的数量=指定输入的代币数量(要支付的 token0 的数量)\n            fee\n        );\n\n        //更新后的价格\n        sqrtPriceX96=state.sqrtPriceX96;\n        tick=TickMath.getTickAtSqrtPrice(sqrtPriceX96);\n\n        //计算手续费\n        //手续费乘以 FixedPoint128.Q128（2 的 96 次方），然后除以流动性数量得到的 （池子单个流动性单位手续费）\n        state.feeGrowthGlobalX128 += FullMath.mulDiv(\n            state.feeAmount,\n            FixedPoint128.Q128,\n            liquidity\n        );\n        if(zeroForOne){\n            feeGrowthGlobal0X128=state.feeGrowthGlobalX128;\n        }else{\n            feeGrowthGlobal1X128=state.feeGrowthGlobalX128;\n        }\n\n        //计算交易后用户手里的token0和token1的数量\n        //根据精确输入或精确输出模式，更新剩余交换量和计算量。\n        if(exactInput){\n            //精确输入: amountSpecifiedRemaining 减少（输入量 + 费用），amountCalculated 减少输出量（因为输出为负）\n            state.amountSpecifiedRemaining -= int256(state.amountIn + state.feeAmount);\n            state.amountCalculated = state.amountCalculated.sub(int256(state.amountOut));\n        }else{\n            //精确输出: amountSpecifiedRemaining 增加输出量（因为输出为负），amountCalculated 增加（输入量 + 费用）。\n            state.amountSpecifiedRemaining += int256(state.amountOut);\n            state.amountCalculated = state.amountCalculated.add(int256(state.amountIn + state.feeAmount));\n        }\n        // 计算最终代币变化量\n        (amount0,amount1)= zeroForOne == exactInput\n            ? (amountSpecified - state.amountSpecifiedRemaining, state.amountCalculated)\n            : (state.amountCalculated, amountSpecified - state.amountSpecifiedRemaining);\n\n\n        // 执行代币转账和回调\n        if (zeroForOne){\n            // 记录当前余额，用于后续检查\n            uint256 balance0Before=_balance0();\n            // 调用回调函数，要求调用者支付token0 给 Pool 转入 token0\n            ISwapCallback(msg.sender).swapCallback(amount0, amount1, data);\n            // 检查余额变化，确保调用者支付了足够的token0\n            require(balance0Before.add(uint256(amount0))<=_balance0(), \"IIA\");\n            // 如果是token0 → token1，将token1转账给接收者\n            if(amount1 <0)\n                TransferHelper.safeTransfer(token1, recipient, uint256(-amount1));\n            }\n        else{\n           // callback 中需要给 Pool 转入 token\n            uint256 balance1Before = _balance1();\n            ISwapCallback(msg.sender).swapCallback(amount0, amount1, data);\n            require(balance1Before.add(uint256(amount1))<=_balance1(), \"IIA\");\n             // 转 Token 给用户\n             if(amount0 <0){\n                TransferHelper.safeTransfer(token0, recipient, uint256(-amount0));\n             }\n        }\n        emit Swap(msg.sender, recipient, amount0, amount1, sqrtPriceX96, liquidity,tick);\n    }\n    /// @dev Get the pool's balance of token0\n    function _balance0() private view returns (uint256){\n        (bool success,bytes memory data)=token0.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n        require(success&&data.length>=32,\"Failed to get balance of token0\");\n        return abi.decode(data, (uint256));\n    }\n\n    function _balance1() private view returns (uint256){\n        (bool success,bytes memory data)=token1.staticcall(abi.encodeWithSelector(IERC20.balanceOf.selector, address(this)));\n        require(success&&data.length>=32,\"Failed to get balance of token1\");\n        return abi.decode(data, (uint256));\n    }\n\n\n    /**\n     * @notice 获取指定地址的流动性位置信息\n     * @param owner 位置所有者地址\n     */\n     function getPosition(address owner) external view override returns (uint128 _liquidity,uint256 feeGrowthInside0LastX128,uint256 feeGrowthInside1LastX128,uint128 tokensOwed0,uint128 tokensOwed1)\n        {\n            return (\n                positions[owner].liquidity,\n                positions[owner].feeGrowthInside0LastX128,\n                positions[owner].feeGrowthInside1LastX128,\n                positions[owner].tokensOwed0,\n                positions[owner].tokensOwed1\n            );\n        }\n}\n"
    },
    "contracts/PoolManager.sol": {
      "content": "//SPDX-License-Identifier: MIT\r\n//这个合约并不是必须的，它只是为了给前端提供数据，\r\n//推荐将这些数据存储在服务端（Uniswap 的做法），\r\n//通过调用服务端的接口来保存、获取这些数据，\r\n//这样的话既可以提高操作数据的响应速度，又可以减少合约存储数据的 gas 开销。\r\n\r\npragma solidity ^0.8.0;\r\n\r\nimport \"./interfaces/IPoolManager.sol\";\r\nimport \"./Factory.sol\";\r\nimport \"./interfaces/IPool.sol\";\r\n\r\ncontract PoolManager is Factory,IPoolManager {\r\n\r\n    Pair[] public pairs;\r\n\r\n    //用于查询 DEX 是否支持某一交易对的交易\r\n    function getPairs() external view override returns (Pair[] memory){\r\n        return pairs;\r\n    }\r\n\r\n    /// @notice 获取所有池子信息 未优化（gas 消耗太大 正常后端返回）\r\n    function getAllPools() external view override returns (PoolInfo[] memory poolsInfo){\r\n        uint32 length=0;\r\n         // 先算一下大小，从 pools 获取\r\n        for (uint32 i=0;i<pairs.length;i++){\r\n            length+=uint32(pools[pairs[i].token0][pairs[i].token1].length);\r\n        }\r\n        // 再填充数据\r\n        poolsInfo = new PoolInfo[](length);\r\n        uint256 index;\r\n        for (uint32 i=0;i<pairs.length;i++){\r\n            // 获取同一交易对的所有池子\r\n            address[] memory addresses =pools[pairs[i].token0][pairs[i].token1];\r\n                for(uint32 j=0;j<addresses.length;j++){\r\n                    IPool pool=IPool(addresses[j]);\r\n                    poolsInfo[index] = PoolInfo(\r\n                        {\r\n                            pool: addresses[j],\r\n                            token0: pool.token0(),\r\n                            token1: pool.token1(),\r\n                            index: j,\r\n                            fee: pool.fee(),\r\n                            feeProtocol: 0,\r\n                            tickLower: pool.tickLower(),\r\n                            tickUpper: pool.tickUpper(),\r\n                            tick: pool.tick(),\r\n                            sqrtPriceX96: pool.sqrtPriceX96(),\r\n                            liquidity: pool.liquidity()\r\n                        }\r\n                    );\r\n                    index++;\r\n                }\r\n            }\r\n            return poolsInfo;\r\n    }\r\n\r\n    \r\n    \r\n    function createAndInitializePoolIfNecessary(CreateAndInitializeParams calldata params) external payable override returns (address poolAddress){\r\n        // 要求 token0 < token1。因为在这个方法中需要传入初始化的价格，而在交易池中价格是按照 token0/token1 的方式计算的，\r\n        // 做这个限制可以避免 LP 不小心初始化错误的价格。\r\n        require(params.token0 < params.token1, \"TokenA must be less than TokenB\");\r\n\r\n        // 创建池子\r\n        poolAddress = this.createPool(params.token0, params.token1, params.tickLower, params.tickUpper, params.fee);\r\n        // 获取池子合约\r\n        IPool pool =IPool(poolAddress);\r\n        // 获取同一交易对的数量\r\n        uint256 index=pools[pool.token0()][pool.token1()].length;\r\n\r\n         // 新创建的池子，没有初始化价格，需要初始化价格\r\n         if(pool.sqrtPriceX96() == 0){\r\n            pool.initialize(params.sqrtPriceX96);\r\n\r\n            if (index ==1){\r\n                pairs.push(Pair(pool.token0(),pool.token1()));\r\n            }\r\n         }\r\n\r\n    }\r\n\r\n\r\n}"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}